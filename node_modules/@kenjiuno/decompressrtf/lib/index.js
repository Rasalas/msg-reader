"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decompressRTF = void 0;
var Stream = /** @class */ (function () {
    function Stream(buf) {
        this.buf = buf;
    }
    Stream.prototype.readInt32LE = function (offset) {
        var value = (this.buf[offset] & 255)
            | ((this.buf[offset + 1] & 255) << 8)
            | ((this.buf[offset + 2] & 255) << 16)
            | ((this.buf[offset + 3] & 255) << 24);
        return value;
    };
    Stream.prototype.readUInt16BE = function (offset) {
        var value = ((this.buf[offset] & 255) << 8)
            | (this.buf[offset + 1] & 255);
        return value;
    };
    Stream.prototype.readUInt8 = function (offset) {
        var value = this.buf[offset] & 255;
        return value;
    };
    Stream.prototype.writeUInt8 = function (value, offset) {
        this.buf[offset] = value & 255;
    };
    return Stream;
}());
/**
 * Decompress PR_RTF_COMPRESSED (PidTagRtfCompressed) data
 *
 * Check these:
 *
 * - The Compressed RTF Format
 *   https://www.freeutils.net/source/jtnef/rtfcompressed
 *
 * - 2.1.3.1 RTF Compression Format
 *   https://msdn.microsoft.com/en-us/library/ee159164(v=exchg.80).aspx
 *
 */
function decompressRTF(inputArray) {
    if (inputArray.length < 16) {
        throw new Error("At least 16 bytes");
    }
    var input = new Stream(inputArray);
    var fileSize = input.readInt32LE(0);
    var rawSize = input.readInt32LE(4);
    var compType = input.readInt32LE(8);
    var crc = input.readInt32LE(12);
    var COMPRESSED = 0x75465A4C;
    var UNCOMPRESSED = 0x414C454D;
    if (compType == COMPRESSED) {
        var initialDictionary = "{\\rtf1\\ansi\\mac\\deff0\\deftab720{\\fonttbl;}{\\f0\\fnil \\froman \\fswi"
            + "ss \\fmodern \\fscript \\fdecor MS Sans SerifSymbolArialTimes New Ro"
            + "manCourier{\\colortbl\\red0\\green0\\blue0\r\n\\par \\pard\\plain\\f0\\fs20\\"
            + "b\\i\\u\\tab\\tx";
        //if (initialDictionary.length != 207) throw new Error("Fix initialDictionary!");
        var outputArray = []; // automatically expanded
        var output = new Stream(outputArray);
        var outPos = 0;
        var inPos = 16;
        var control = void 0;
        for (var x = 0; x < initialDictionary.length; x += 1) {
            output.writeUInt8(initialDictionary.charCodeAt(x), outPos);
            outPos += 1;
        }
        var inEnd = fileSize + 4;
        for (var run_1 = 0; inPos < inEnd; run_1 = (run_1 + 1) & 7) {
            if (0 == run_1) {
                control = input.readUInt8(inPos);
                inPos += 1;
            }
            if (0 != ((1 << run_1) & control)) {
                // dictionary
                var token = input.readUInt16BE(inPos);
                inPos += 2;
                var offset = token >> 4;
                var length_1 = (token & 15) + 2;
                var readPos = (outPos & (~4095)) + offset;
                if (readPos == outPos) {
                    break;
                }
                if (readPos > outPos) {
                    readPos -= 4096;
                }
                for (var x = 0; x < length_1; x += 1) {
                    var octet = output.readUInt8(readPos);
                    output.writeUInt8(octet, outPos);
                    readPos += 1;
                    outPos += 1;
                }
            }
            else {
                // literal
                var octet = input.readUInt8(inPos);
                output.writeUInt8(octet, outPos);
                inPos += 1;
                outPos += 1;
            }
        }
        return outputArray.slice(initialDictionary.length);
    }
    else if (compType == UNCOMPRESSED) {
        return inputArray.slice(16, 16 + rawSize);
    }
    else {
        throw new Error("Either COMPRESSED or UNCOMPRESSED");
    }
}
exports.decompressRTF = decompressRTF;
