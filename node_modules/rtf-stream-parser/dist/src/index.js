"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deEncapsulateStream = exports.deEncapsulateSync = exports.DeEncapsulate = exports.Tokenize = void 0;
const de_encapsulate_1 = require("./de-encapsulate");
Object.defineProperty(exports, "DeEncapsulate", { enumerable: true, get: function () { return de_encapsulate_1.DeEncapsulate; } });
const stream_flow_1 = require("./stream-flow");
const tokenize_1 = require("./tokenize");
Object.defineProperty(exports, "Tokenize", { enumerable: true, get: function () { return tokenize_1.Tokenize; } });
const utils_1 = require("./utils");
function deEncapsulateSync(rtf, options) {
    const onError = (err) => {
        if (utils_1.isDef(err)) {
            throw err;
        }
    };
    const stream1 = new tokenize_1.Tokenize();
    const stream2 = new de_encapsulate_1.DeEncapsulate(options);
    stream1.push = (token) => {
        stream2._transform(token, '', onError);
        return true;
    };
    const chunks = [];
    stream2.push = (piece) => {
        chunks.push(piece);
        return true;
    };
    stream1._transform(rtf, undefined, onError);
    stream1._flush(onError);
    stream2._flush(onError);
    const result = !options || !options.outputMode || options.outputMode === 'string'
        ? chunks.join('')
        : Buffer.concat(chunks);
    return {
        mode: stream2.isHtml ? 'html' : 'text',
        text: result
    };
}
exports.deEncapsulateSync = deEncapsulateSync;
function deEncapsulateStream(streamIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const stream1 = new tokenize_1.Tokenize();
        const stream2 = new de_encapsulate_1.DeEncapsulate(options);
        const chunks = yield stream_flow_1.streamFlow(streamIn, stream1, stream2);
        const result = !options || !options.outputMode || options.outputMode === 'string'
            ? chunks.join('')
            : Buffer.concat(chunks);
        return {
            mode: stream2.isHtml ? 'html' : 'text',
            text: result
        };
    });
}
exports.deEncapsulateStream = deEncapsulateStream;
